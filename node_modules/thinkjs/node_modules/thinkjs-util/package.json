{
  "name": "thinkjs-util",
  "version": "1.1.1",
  "description": "util for thinkjs",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/welefen/thinkjs-util.git"
  },
  "dependencies": {
    "es6-promise": "2.0.0"
  },
  "author": "",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/welefen/thinkjs-util/issues"
  },
  "readme": "thinkjs-util\n============\n\n```\nvar util = require('thinkjs-util');\n```\n\n下面所有方法都是在util下的。\n\n### Promise\n\nthinkjs中的Promise使用了[es6-promise](http://www.html5rocks.com/en/tutorials/es6/promises/) 库，是个全局对象， 含有如下的方法：\n\n* `all(array)` \n* `resolve(promise | thenable | obj)` \n* `reject(obj)`\n* `race(array)`\n\n### Class(superCls, prop)\n\n* superCls `function` 父类\n* prop `function | object` 如果是function，则执行这个function，并获取结果\n* return `function`\n\n通过该函数动态创建一个类，可以实现类继承和自动调用init方法的功能，同时实例化类的时候可以省去`new`。如果只传了一个参数，则认为是prop。\n\n\n```js\n//A为通过Class动态创建的一个类\nvar A = Class(function(){\n    return {\n        init: function(name){\n            this.name = name;\n        },\n        getName: function(){\n            return \"A \" + this.name;\n        }\n    }\n});\n//实例化类A，可以不写new\nvar instance = A(\"welefen\");\nvar name = instance.getName(); /*name is `A welefen`*/\n```\n\n通过Class函数创建的类支持继承，含有以下2个静态方法：\n\n* `extend(obj)` 扩展方法到类的原型上\n* `inherits(superCls)` 指定该类的父类\n\n子类可以继承父类的方法，同时可以对方法进行重写。\n\n```js\nvar B = Class(A, {}); //B类从A类继承而来\n//B类的实例化\nvar instance = B(\"welefen\");\nvar name = instance.getName(); /*name is `A welefen`*/\nB.extend({ \n    getName: function(){ //B类对getName方法进行了重写\n        return \"B \" + this.name;\n    }\n});\nvar name = instance.getName(); /*name is `B welefen`*/\n```\n\n也可以在重写的方法里调用父类的方法，如：\n\n```js\nvar C = Class(A, {\n    getName: function(){\n        var name = this.super(\"getName\");\n        return \"C \" + name;\n    }\n}); //从A类继承\nvar instance = C(\"welefen\");\nvar name = instance.getName(); /*name is `C A welefen`*/\n```\n\n如果有多级继承，想跨级调用父类的方法时，只能通过apply的方式调用原形链上的方法，如：\n\n```js\nvar D = Class(C, {\n    getName: function(){\n        var name = A.prototype.getName.apply(this, arguments);\n        return 'D' + name;\n    }\n}); //从C类继承\nvar instance = D('welefen');\nvar name = instnace.getName(); /*name is `D A welefen`*/;\n```\n\n`注意：` 不可用下面的方式来继承\n\n```js\nvar A = Class();\nvar B = Class({getName: function(){}}).inherits(A); //此时B不含有getName方法\n```\n\n\n### extend(target, source1, source2, ...)\n\n* target `object` \n* source1  `object`\n* return  `object`\n\n将source1, source2等对象上的属性或方法复制到target对象上，类似于jQuery里的$.extend方法。\n\n默认为深度复制，可以将第一个参数传`false`进行浅度复制。  \n\n`注意`： 赋值时，忽略值为undefined的属性。\n\n\n### isBoolean(obj)\n\n* `obj` 要检测的对象\n* `return` true OR false\n\n检测一个对象是否是布尔值。\n\n```js\n//判断是否是布尔值\nisBoolean(true); //true\nisBoolean(false); //true\n```\n\n\n### isNumber(obj)\n\n检测一个对象是否是数字。\n\n```js\nisNumber(1); //true\nisNumber(1.21); //true\n```\n\n### isObject(obj)\n\n检测是否是对象\n\n```js\nisObject({}); //true\nisObject({name: \"welefen\"}); //true\n```\n\n### isString(obj)\n\n检测是否是字符串\n\n```js\nisString(\"xxx\"); // true\nisString(new String(\"xxx\")); //true\n```\n\n### isFunction(obj)\n\n检测是否是函数\n\n```js\nisFunction(function(){}); //true\nisFunction(new Function(\"\")); //true\n```\n\n### isDate(obj)\n\n检测是否是日期对象\n\n```js\nisDate(new Date()); //true\n```\n\n### isRegexp(obj)\n\n检测是否是正则\n\n```js\nisRegexp(/\\w+/); //true\nisRegexp(new RegExp(\"/\\\\w+/\")); //true\n```\n\n### isError(obj)\n\n检测是否是个错误\n\n```js\nisError(new Error(\"xxx\")); //true\n```\n\n### isEmpty(obj)\n\n检测是否为空\n\n```js\n//检测是否为空\nisEmpty({}); //true\nisEmpty([]); //true\nisEmpty(\"\"); //true\nisEmpty(0); //true\nisEmpty(null); //true\nisEmpty(undefined); //true\nisEmpty(false); //true\n```\n\n### isArray(obj)\n\n检测是否是数组\n\n```js\nisArray([]); //true\nisArray([1, 2]); //true\nisArray(new Array(10)); //true\n```\n\n### isIP4(obj)\n\n检测是否是IP4\n\n```js\nisIP4(\"10.0.0.1\"); //true\nisIP4(\"192.168.1.1\"); //true\n```\n\n### isIP6(obj)\n\n检测是否是IP6\n\n```js\nisIP6(\"2031:0000:130f:0000:0000:09c0:876a:130b\"); //true\nisIP6(\"2031:0000:130f::09c0:876a:130b\"); //true\n```\n\n### isIP(obj)\n\n检测是否是IP\n\n```js\nisIP(\"10.0.0.1\"); //true\nisIP(\"192.168.1.1\"); //true\nisIP(\"2031:0000:130f:0000:0000:09c0:876a:130b\"); //true ip6\n```\n\n### isFile(file)\n\n检测是否是文件，如果在不存在则返回false\n\n```js\nisFile(\"/home/welefen/a.txt\"); //true\nisFile(\"/home/welefen/dirname\"); //false\n```\n\n### isDir(dir)\n\n检测是否是目录，如果不存在则返回false\n\n```js\nisDir(\"/home/welefen/dirname\"); //true\n```\n\n### isBuffer(buffer)\n\n检测是否是Buffer\n\n```js\nisBuffer(new Buffer(20)); //true\n```\n\n### isNumberString(obj)\n\n是否是字符串类型的数字\n\n```js\nisNumberString(1); //true\nisNumberString(\"1\"); //true\nisNumberString(\"1.23\"); //true\n```\n\n### isPromise(promise)\n\n检测是否是个promise\n\n```js\nisPromise(new Promise(function(){})); //true\nisPromise(getPromise()); //true\n```\n\n### isWritable(p)\n\n判断文件或者目录是否可写，如果不存在则返回false\n\n### mkdir(p, mode)\n\n递归的创建目录\n\n* `p` 要创建的目录\n* `mode` 权限，默认为`0777`\n\n```js\n//假设/home/welefen/a/b/不存在\nmkdir(\"/home/welefen/a/b\");\nmkdir(\"home/welefne/a/b/c/d/e\"); //递归创建子目录\n```\n\n### chmod(p, mode)\n\n修改目录权限，如果目录不存在则直接返回\n\n```js\nchmod(\"/home/welefen/a\", 0777);\n```\n\n### ucfirst(name)\n\n将首字符变成大写，其他变成小写\n\n```js\nucfirst(\"welefen\"); // Welefen\nucfirst(\"WELEFEN\"); // Welefen\n```\n\n### md5(str)\n\n获取字符串的md5值，如果传入的参数不是字符串，则自动转为字符串\n\n```js\nmd5(\"welefen\"); //59dff65d54a8fa28fe372b75d459e13b\n```\n\n### getPromise(obj, reject)\n\n获取一个promise对象。默认为`resolve promise`，如果reject参数为true，那么返回`reject promise`。\n\n如果obj是promise，那么直接返回。\n\n```js\ngetPromise([]); //resolve promise\ngetPromise(new Error(\"\"), true); //reject promise\nvar promise = getPromise(\"\");\ngetPromise(promise); //\n```\n\n### getDefer()\n\n获取一个`Deferred`对象，对象含有如下的属性或者方法：\n\n* `resolve` 方法：将promise resolve\n* `reject` 方法：将promise reject\n* `promise` 属性：Deferred对应的Promise\n\n```js\n//把读取文件内容变成promise\nvar fs = require(\"fs\");\nfunction getFileContent(file){\n    var deferred = getDefer();\n    fs.readFile(file, \"utf8\", function(err, content){\n        //如果有错误，那么reject\n        if(err){\n            deferred.reject(err);\n        }else{\n            //成功读取到内容\n            deferred.resolve(content);\n        }\n    })\n    return deferred.promise;\n};\n\ngetFileContent(\"/home/welefen/a.txt\").then(function(content){\n    //\n}).catch(function(err){\n    console.log(err.stack);\n})\n```\n\n`deferred.promise`默认为`pedding`状态，`pedding`状态的promise不会执行后续的then，也不会执行catch。如果想阻止后面的代码继续执行，那么可以返回一个`pedding promise`。\n\n```js\n//返回一个pedding promise\nvar getPeddingPromise = function(){\n    var deferred = getDefer();\n    return deferred.promise;\n}\ngetPeddingPromise().then(function(){\n    //这里的代码不会执行\n}).catch(function(){\n    //这里的代码也不会执行\n})\n```\n\n### getObject(name, value)\n\n在项目中，经常会遇到要动态创建一个对象。如：\n\n```js\nvar data = {};\n//name和value从其他地方动态读取出来的\ndata[name] = value;\n//有时候还要设置多个\ndata[name1] = value1;\n```\n\n为了方便创建对象，可以通过`getObject`来完成。\n\n```js\n//单个属性\nvar data = getObject(name, value);\n//多个属性\nvar data = getObject([name, name1], [value, valu1]);\n//更多的属性\nvar data = getObject([name, name1, name2, name3], [value, value1, value2, value3]);\n```\n\n### arrToObj(arr, key, valueKey)\n\n在项目中，经常会从数据库中查询多条数据，然后对数据进行一些操作。如：根据特定的key进行去除等。我们一般借助对象来完成此类操作，这时候需要把数组转化为对象。\n\n可以借助arrToObj来完成。\n\n```js\n\n//从数据库中查询出来的数据对象\nvar arr = [{id: 10, name: \"name1\", value: \"value1\"}, {id: 11, name: \"name2\", value: \"value2\"}];\n//把id值作为key生成一个对象\n/* data = {10: {id: 10, name: \"name1\", value: \"value1\"}, 11: {id: 11, name: \"name2\", value: \"value2\"}} */\nvar data = arrToObj(arr, \"id\");\n//把id值作为key，只需要name的值\n//data = {10: \"name1\", 11: \"name2\"}\nvar data = arrToObj(arr, \"id\", \"name\");\n//只获取id的值\n// ids = [10, 11];\nvar ids = arrToObj(arr, \"id\", null);\n```\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/welefen/thinkjs-util",
  "_id": "thinkjs-util@1.1.1",
  "dist": {
    "shasum": "d1029f8b82bb0968328b6a2c45accddc9461bbc1"
  },
  "_from": "thinkjs-util@>=1.0.0",
  "_resolved": "https://registry.npmjs.org/thinkjs-util/-/thinkjs-util-1.1.1.tgz"
}
